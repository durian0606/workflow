<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>작업 관리</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
      background: linear-gradient(135deg, #0d7377 0%, #14ccb8 100%);
      touch-action: pan-y;
    }

    /* 로그인 화면 */
    .login-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .login-box {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 400px;
    }

    .login-title {
      font-size: 28px;
      font-weight: 600;
      color: #0d7377;
      margin-bottom: 30px;
      text-align: center;
    }

    .user-list-title {
      font-size: 14px;
      color: #666;
      margin-bottom: 16px;
      text-align: center;
    }

    .user-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .user-card {
      padding: 20px;
      background: #f5f7fa;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .user-card:hover {
      background: #0d7377;
      color: white;
      border-color: #0d7377;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(13, 115, 119, 0.3);
    }

    .user-card-avatar {
      width: 50px;
      height: 50px;
      background: rgba(13, 115, 119, 0.1);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 20px;
      margin: 0 auto 10px;
      color: #0d7377;
    }

    .user-card:hover .user-card-avatar {
      background: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .user-card-name {
      font-weight: 500;
      font-size: 15px;
    }

    .admin-section {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid #e0e0e0;
    }

    .admin-input {
      width: 100%;
      padding: 12px 14px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .admin-input:focus {
      outline: none;
      border-color: #0d7377;
    }

    .admin-btn {
      width: 100%;
      padding: 12px;
      background: #0d7377;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }

    .admin-btn:hover {
      background: #14ccb8;
    }

    /* 메인 앱 */
    .app-container {
      display: none;
      min-height: 100vh;
      background: #f5f7fa;
    }

    .app-container.active {
      display: flex;
      flex-direction: column;
    }

    .app-header {
      background: linear-gradient(135deg, #0d7377 0%, #14ccb8 100%);
      color: white;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .header-row-1 {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-row-2 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 18px;
    }

    .header-info {
      display: flex;
      flex-direction: column;
    }

    .app-title {
      font-size: 18px;
      font-weight: 600;
    }

    .user-name {
      font-size: 13px;
      opacity: 0.9;
    }

    .header-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .header-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .left-panel {
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    .date-display {
      font-size: 15px;
      font-weight: 600;
      color: white;
      flex: 1;
    }

    .nav-buttons {
      display: flex;
      gap: 6px;
    }

    .nav-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
      white-space: nowrap;
    }

    .nav-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .task-input-container {
      background: white;
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
    }

    .task-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .form-row {
      display: flex;
      gap: 10px;
    }

    .task-input {
      flex: 1;
      padding: 14px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 15px;
      transition: border 0.2s;
    }

    .task-input:focus {
      outline: none;
      border-color: #0d7377;
    }

    .site-select-btn {
      background: #f5f7fa;
      border: 2px solid #e0e0e0;
      color: #333;
      padding: 14px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .site-select-btn:hover {
      background: #e8eef3;
      border-color: #0d7377;
    }

    .add-btn {
      background: #0d7377;
      border: none;
      color: white;
      padding: 14px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .add-btn:hover {
      background: #14ccb8;
    }

    .task-container {
      background: white;
      padding: 20px;
      max-height: 600px;
      overflow-y: auto;
    }

    .task-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .task-card {
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.2s;
      position: relative;
    }

    .task-card:hover {
      border-color: #0d7377;
      box-shadow: 0 2px 8px rgba(13, 115, 119, 0.15);
    }

    .task-card.dragging {
      opacity: 0.5;
    }

    .task-card.drag-over {
      border-color: #14ccb8;
      background: #f0f9f9;
    }

    .drag-handle {
      cursor: grab;
      font-size: 36px;
      color: #0d7377;
      user-select: none;
      padding: 10px;
      line-height: 1;
      background: rgba(13, 115, 119, 0.08);
      border-radius: 8px;
      border: 2px solid rgba(13, 115, 119, 0.2);
      transition: all 0.2s;
      position: relative;
    }

    /* 드래그 핸들에 툴팁 추가 */
    .drag-handle::after {
      content: '드래그';
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      background: #0d7377;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      white-space: nowrap;
    }

    .drag-handle:hover::after {
      opacity: 1;
    }

    .drag-handle:hover {
      background: rgba(13, 115, 119, 0.15);
      border-color: rgba(13, 115, 119, 0.4);
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(13, 115, 119, 0.2);
    }

    .drag-handle:active {
      cursor: grabbing;
      background: rgba(13, 115, 119, 0.25);
      transform: scale(0.98);
    }

    .order-number {
      background: #0d7377;
      color: white;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 13px;
      flex-shrink: 0;
    }

    .task-checkbox {
      width: 24px;
      height: 24px;
      border: 2px solid #0d7377;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .task-checkbox:hover {
      background: #e8f4f5;
      border-width: 3px;
    }

    .task-card.completed .task-checkbox {
      background: #0d7377;
      position: relative;
    }

    .task-card.completed .task-checkbox::after {
      content: '✓';
      position: absolute;
      color: white;
      font-weight: bold;
      font-size: 14px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .task-card-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .task-title {
      font-size: 15px;
      font-weight: 500;
      color: #333;
    }

    .task-card.completed .task-title {
      text-decoration: line-through;
      color: #999;
    }

    .task-card.my-task {
      border-left: 4px solid #0d7377;
      background: linear-gradient(to right, rgba(13, 115, 119, 0.03), white);
    }

    .person-select-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .select-wrapper {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .select-label {
      font-size: 11px;
      color: #999;
      font-weight: 500;
    }

    .assignee-select {
      padding: 6px 10px;
      border: 1.5px solid #e0e0e0;
      border-radius: 6px;
      font-size: 13px;
      background: white;
      cursor: pointer;
      transition: border 0.2s;
    }

    .assignee-select:hover {
      border-color: #0d7377;
    }

    .assignee-select:disabled {
      background: #f5f7fa;
      cursor: not-allowed;
    }

    .action-btn {
      background: #ffe0e0;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .action-btn:hover {
      background: #ffcccc;
      transform: scale(1.1);
    }

    .map-section {
      background: white;
      margin: 20px;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      min-height: 500px;
    }

    .map-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .map-section-title {
      font-size: 16px;
      font-weight: 600;
      color: #333;
    }

    .section-header {
      font-size: 15px;
      font-weight: 600;
      color: #333;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
      padding: 8px;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .section-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    .section-header.my-work {
      color: #0d7377;
    }

    .section-toggle {
      margin-right: 8px;
      font-size: 14px;
      transition: transform 0.3s;
    }

    .section-header.collapsed .section-toggle {
      transform: rotate(-90deg);
    }

    .task-grid.collapsed {
      display: none;
    }

    .section-divider {
      margin: 20px 0;
      border-bottom: 1px solid #e8e8e8;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #999;
    }

    .empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    /* 지도 */
    #map {
      width: 100%;
      height: 450px;
      border-radius: 8px;
    }

    .map-controls {
      display: flex;
      gap: 10px;
    }

    .map-btn {
      background: #0d7377;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .map-btn:hover {
      background: #14ccb8;
    }

    .map-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* 모달 */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      color: #999;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
    }

    /* 작업 타임라인 모달 */
    .timeline-item {
      padding: 16px;
      background: #f5f7fa;
      border-radius: 8px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .timeline-item.active {
      background: #e8f4f5;
      border-left: 4px solid #0d7377;
    }

    .timeline-work {
      font-size: 15px;
      color: #333;
      font-weight: 500;
    }

    .timeline-date {
      font-size: 13px;
      color: #666;
    }

    /* 현장 선택 모달 */
    .site-list {
      list-style: none;
      margin-bottom: 20px;
    }

    .site-item {
      padding: 14px;
      background: #f5f7fa;
      border-radius: 8px;
      margin-bottom: 8px;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .site-item:hover {
      background: #e8eef3;
    }

    .site-item-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .site-item-name {
      font-size: 14px;
      color: #333;
      font-weight: 600;
    }

    .site-item-address {
      font-size: 12px;
      color: #666;
    }

    .site-item-delete {
      background: #ffe0e0;
      border: none;
      color: #d13438;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    /* 완료 기한 선택 모달 */
    .deadline-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .deadline-modal.active {
      display: flex;
    }

    .deadline-modal-content {
      background: white;
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .deadline-modal-header {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 20px;
    }

    .deadline-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .deadline-option {
      padding: 14px 16px;
      background: #f5f7fa;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      font-size: 15px;
    }

    .deadline-option:hover {
      background: #0d7377;
      color: white;
      border-color: #0d7377;
    }

    .deadline-option-label {
      font-weight: 500;
      display: block;
    }

    .deadline-option-date {
      font-size: 13px;
      opacity: 0.7;
      margin-top: 4px;
    }

    .deadline-custom {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .deadline-date-input {
      flex: 1;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
    }

    .deadline-date-input:focus {
      outline: none;
      border-color: #0d7377;
    }

    .deadline-confirm-btn {
      padding: 12px 24px;
      background: #0d7377;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .deadline-confirm-btn:hover {
      background: #14ccb8;
    }

    .deadline-label-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      cursor: pointer;
    }

    .deadline-label-text {
      font-size: 12px;
      color: #666;
    }

    .deadline-date-tag {
      display: inline-block;
      padding: 4px 10px;
      background: #e3f2fd;
      color: #1976d2;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }

    .add-site-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e0e0e0;
    }

    .site-list-section {
      margin-top: 20px;
    }

    .site-list-title {
      font-size: 14px;
      color: #666;
      margin-bottom: 12px;
      font-weight: 600;
    }

    /* 기한 초과 작업 스타일 */
    .task-card.overdue {
      border-left: 4px solid #f44336;
      background: #ffebee;
    }

    .task-card.overdue .task-title {
      color: #d32f2f;
      font-weight: 600;
    }

    .deadline-date-tag.overdue {
      background: #f44336;
      color: white;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .overdue-warning {
      display: inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      background: #f44336;
      color: white;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      animation: pulse 1.5s infinite;
    }

    .date-label {
      font-size: 12px;
      color: #666;
      margin-right: 6px;
    }

    .test-date-label {
      display: inline-block;
      padding: 4px 10px;
      background: #fff3e0;
      color: #f57c00;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }

    /* 로딩 오버레이 */
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 20000;
      align-items: center;
      justify-content: center;
    }

    .loading-overlay.active {
      display: flex;
    }

    .loading-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #0d7377;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      font-size: 14px;
      color: #666;
    }

    @media (max-width: 768px) {
      .task-container {
        max-height: 400px;
      }

      .map-section {
        min-height: 350px;
        margin: 10px;
        padding: 15px;
      }

      #map {
        height: 300px;
      }

      /* 완료 섹션 스크롤바 스타일 */
      .task-grid {
        scrollbar-width: thin;
        scrollbar-color: #0d7377 #f5f7fa;
      }

      .task-grid::-webkit-scrollbar {
        width: 8px;
      }

      .task-grid::-webkit-scrollbar-track {
        background: #f5f7fa;
        border-radius: 4px;
      }

      .task-grid::-webkit-scrollbar-thumb {
        background: #0d7377;
        border-radius: 4px;
      }

      .task-grid::-webkit-scrollbar-thumb:hover {
        background: #14ccb8;
      }
    }
  </style>
</head>

<body>
  <!-- 로딩 오버레이 -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div class="loading-text">경로를 계산하는 중...</div>
    </div>
  </div>

  <!-- 로그인 화면 -->
  <div class="login-container" id="loginContainer">
    <div class="login-box">
      <h1 class="login-title">작업 관리</h1>
      <p class="user-list-title">사용자를 선택하세요</p>
      <div class="user-grid" id="userGrid"></div>

      <div class="admin-section">
        <input type="text" class="admin-input" id="newUserInput" placeholder="새 사용자 추가">
        <button class="admin-btn" onclick="addNewUser()">추가</button>
      </div>
    </div>
  </div>

  <!-- 메인 앱 -->
  <div class="app-container" id="appContainer">
    <div class="app-header">
      <!-- 첫 번째 줄: 로고, 사용자 정보, 현장, 로그아웃 -->
      <div class="header-row-1">
        <div class="header-left">
          <div class="user-avatar" id="userAvatar"></div>
          <div class="header-info">
            <div class="app-title">작업 관리</div>
            <div class="user-name" id="headerUserName"></div>
          </div>
        </div>
        <div class="header-right">
          <button class="header-btn" onclick="toggleSiteModal()">📍 현장추가</button>
          <button class="header-btn" onclick="logout()">로그아웃</button>
        </div>
      </div>

      <!-- 두 번째 줄: 날짜 네비게이션 -->
      <div class="header-row-2">
        <div class="date-display" id="dateDisplay"></div>
        <div class="nav-buttons">
          <button class="nav-btn" onclick="goToToday()">오늘</button>
          <button class="nav-btn" onclick="changeDate(-1)">◀</button>
          <button class="nav-btn" onclick="changeDate(1)">▶</button>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="left-panel">
        <div class="task-input-container">
          <div class="task-form">
            <div class="form-row">
              <input type="text" class="task-input" id="siteInput" placeholder="현장명">
              <button class="site-select-btn" onclick="toggleSiteSelectModal()">📋 선택</button>
            </div>
            <div class="form-row">
              <input type="text" class="task-input" id="workInput" placeholder="작업 내용 입력">
              <button class="add-btn" onclick="addWork()">+ 추가</button>
            </div>
          </div>
        </div>

        <div class="task-container" id="taskContainer"></div>

        <!-- 지도 섹션 -->
        <div class="map-section">
          <div class="map-section-header">
            <h3 class="map-section-title">🚗 이동 경로</h3>
            <div class="map-controls">
              <button class="map-btn" id="routeBtn" onclick="showRouteFromCurrentLocation()">경로 표시</button>
              <button class="map-btn" onclick="showCurrentLocation()">내 위치</button>
            </div>
          </div>
          <div id="map"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- 작업 타임라인 모달 -->
  <div class="modal-overlay" id="timelineModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="timelineTitle"></h3>
        <button class="close-btn" onclick="closeTimelineModal()">×</button>
      </div>
      <div id="timelineContent"></div>
    </div>
  </div>

  <!-- 현장 관리 모달 -->
  <div class="modal-overlay" id="siteModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">현장 추가</h3>
        <button class="close-btn" onclick="toggleSiteModal()">×</button>
      </div>

      <div class="add-site-form">
        <input type="text" class="task-input" id="newSiteName" placeholder="현장명 입력">
        <input type="text" class="task-input" id="newSiteAddress" placeholder="주소 입력">
        <button class="add-btn" onclick="addSite()">저장</button>
      </div>

      <div class="site-list-section">
        <h4 class="site-list-title">저장된 현장 목록</h4>
        <ul class="site-list" id="siteList"></ul>
      </div>
    </div>
  </div>

  <!-- 완료 기한 선택 모달 -->
  <div class="deadline-modal" id="deadlineModal">
    <div class="deadline-modal-content">
      <div class="deadline-modal-header">완료 기한 선택</div>
      <div class="deadline-options">
        <div class="deadline-option" onclick="selectDeadline('today')">
          <span class="deadline-option-label">오늘</span>
          <span class="deadline-option-date" id="todayDate"></span>
        </div>
        <div class="deadline-option" onclick="selectDeadline('tomorrow')">
          <span class="deadline-option-label">내일</span>
          <span class="deadline-option-date" id="tomorrowDate"></span>
        </div>
        <div class="deadline-option" onclick="selectDeadline('thisWeek')">
          <span class="deadline-option-label">이번주 중 (금요일)</span>
          <span class="deadline-option-date" id="thisWeekDate"></span>
        </div>
        <div class="deadline-custom">
          <input type="date" class="deadline-date-input" id="customDeadlineInput">
          <button class="deadline-confirm-btn" onclick="selectDeadline('custom')">확인</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 현장 선택 모달 -->
  <div class="modal-overlay" id="siteSelectModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">현장 선택</h3>
        <button class="close-btn" onclick="toggleSiteSelectModal()">×</button>
      </div>
      <ul class="site-list" id="siteSelectList"></ul>
    </div>
  </div>

  <!-- Kakao Map API -->
  <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=edfe0792f24f219880fc608009d59a0f&libraries=services"></script>

  <!-- Firebase SDK -->
  <script type="module">
    import {
      initializeApp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getDatabase,
      ref,
      set,
      push,
      onValue,
      update,
      remove
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    const firebaseConfig = {
      apiKey: "AIzaSyAMv0BmH24fyd0F8CUTkSYSXMlvbcnUXU4",
      authDomain: "work-todo-6ab7f.firebaseapp.com",
      databaseURL: "https://work-todo-6ab7f-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "work-todo-6ab7f",
      storageBucket: "work-todo-6ab7f.firebasestorage.app",
      messagingSenderId: "263893669261",
      appId: "1:263893669261:web:bdce10bec177ff1f67d9c4"
    };
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    window.db = database;
    window.dbRef = ref;
    window.dbSet = set;
    window.dbPush = push;
    window.dbOnValue = onValue;
    window.dbUpdate = update;
    window.dbRemove = remove;
    // Firebase 초기화 완료 알림
    window.firebaseReady = true;
    console.log('✅ Firebase initialized');
  </script>

  <script>
    let currentDate = new Date();
    let works = {};
    let assignees = [];
    let sites = {};
    let currentUser = null;
    let map = null;
    let currentMarker = null;
    let currentLocationMarker = null; // 현재 위치 마커
    let routeMarkers = []; // 경로 마커들
    let routeLine = null; // 경로 선
    let currentPosition = null; // 현재 위치 저장
    let isRouteDisplayed = false; // 🆕 경로 표시 중인지 여부
    let draggedElement = null;
    let draggedWorkId = null;
    let originalOrder = []; // 드래그 시작 시 원래 순서 저장
    let isDraggingNow = false; // 현재 드래그 중인지 여부
    // 섹션 접기/펼치기 상태
    let sectionStates = {
      myActive: true,
      teamActive: true,
      completed: true
    };
    // Firebase 준비 대기
    function waitForFirebase() {
      if (window.firebaseReady) {
        initApp();
      } else {
        setTimeout(waitForFirebase, 100);
      }
    }

    function initApp() {
      loadAssignees();
    }
    // 카카오맵 초기화
    function initMap() {
      if (typeof kakao === 'undefined' || !kakao.maps) {
        console.error('카카오맵 API가 로드되지 않았습니다.');
        document.getElementById('map').innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#999;text-align:center;padding:20px;">카카오맵을 불러오는 중입니다...</div>';
        setTimeout(() => {
          if (typeof kakao !== 'undefined' && kakao.maps) {
            initMap();
          }
        }, 1000);
        return;
      }
      try {
        const container = document.getElementById('map');
        const options = {
          center: new kakao.maps.LatLng(37.5665, 126.9780),
          level: 3
        };
        map = new kakao.maps.Map(container, options);
        const mapTypeControl = new kakao.maps.MapTypeControl();
        map.addControl(mapTypeControl, kakao.maps.ControlPosition.TOPRIGHT);
        const zoomControl = new kakao.maps.ZoomControl();
        map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT);
        setTimeout(() => {
          map.relayout();
        }, 100);
        console.log('✅ 지도 초기화 성공!');
      } catch (error) {
        console.error('❌ 지도 초기화 실패:', error);
        document.getElementById('map').innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#999;text-align:center;padding:20px;">지도를 불러올 수 없습니다.<br>페이지를 새로고침 해주세요.</div>';
      }
    }
    // 🆕 현재 위치부터 시작하는 경로 표시
    window.showRouteFromCurrentLocation = function() {
      console.log('🚀 경로 표시 시작');
      if (!map) {
        alert('지도가 초기화되지 않았습니다.');
        return;
      }
      // 내 작업 진행 중 리스트 가져오기
      const searchDate = currentDate.toISOString().split('T')[0];
      const myActiveWorks = [];
      Object.keys(works).forEach(workId => {
        const work = works[workId];
        if (work.completed) return;
        if (work.assignee !== currentUser) return;
        let shouldShow = false;
        if (work.work === '시험' || work.parentWorkId) {
          shouldShow = work.date === searchDate;
        } else {
          shouldShow = work.date <= searchDate;
        }
        if (shouldShow) {
          myActiveWorks.push(work);
        }
      });
      // 🆕 순서대로 정렬 (리스트와 동일한 순서로!)
      myActiveWorks.sort((a, b) => {
        const orderA = typeof a.order === 'number' ? a.order : 999;
        const orderB = typeof b.order === 'number' ? b.order : 999;
        if (orderA === orderB) {
          return a.id.localeCompare(b.id);
        }
        return orderA - orderB;
      });
      console.log('📋 내 작업 진행 중:', myActiveWorks.length, '개');
      if (myActiveWorks.length === 0) {
        alert('표시할 작업이 없습니다.');
        return;
      }
      // 현재 위치 가져오기
      if (navigator.geolocation) {
        document.getElementById('loadingOverlay').classList.add('active');
        document.getElementById('routeBtn').disabled = true;
        console.log('📍 현재 위치 요청 중...');
        // 타임아웃 설정 (10초)
        const timeout = setTimeout(() => {
          document.getElementById('loadingOverlay').classList.remove('active');
          document.getElementById('routeBtn').disabled = false;
          alert('위치 정보를 가져오는데 시간이 너무 오래 걸립니다. 다시 시도해주세요.');
          console.error('❌ 위치 요청 타임아웃');
        }, 10000);
        navigator.geolocation.getCurrentPosition(
          function(position) {
            clearTimeout(timeout);
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            console.log('✅ 현재 위치:', lat, lng);
            currentPosition = new kakao.maps.LatLng(lat, lng);
            // 경로 그리기
            drawRouteFromCurrentLocation(currentPosition, myActiveWorks);
          },
          function(error) {
            clearTimeout(timeout);
            document.getElementById('loadingOverlay').classList.remove('active');
            document.getElementById('routeBtn').disabled = false;
            let errorMsg = '위치 정보를 가져올 수 없습니다.\n\n';
            switch (error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += '위치 권한이 거부되었습니다.\n브라우저 설정에서 위치 권한을 허용해주세요.';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += '위치 정보를 사용할 수 없습니다.';
                break;
              case error.TIMEOUT:
                errorMsg += '위치 정보 요청 시간이 초과되었습니다.';
                break;
              default:
                errorMsg += '알 수 없는 오류가 발생했습니다.';
            }
            alert(errorMsg);
            console.error('❌ 위치 정보 에러:', error);
          }, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      } else {
        alert('이 브라우저는 위치 서비스를 지원하지 않습니다.');
      }
    };
    // 🆕 현재 위치부터 현장들을 순서대로 연결하는 경로 그리기
    function drawRouteFromCurrentLocation(currentPos, myActiveWorks) {
      console.log('🗺️ 경로 그리기 시작');
      // 기존 마커와 선 제거
      if (currentLocationMarker) {
        currentLocationMarker.setMap(null);
      }
      routeMarkers.forEach(marker => marker.setMap(null));
      routeMarkers = [];
      if (routeLine) {
        routeLine.setMap(null);
        routeLine = null;
      }
      // 현장 목록에서 중복 제거하고 순서 유지
      const uniqueSites = [];
      const siteNames = new Set();
      myActiveWorks.forEach(work => {
        if (!siteNames.has(work.site)) {
          uniqueSites.push(work.site);
          siteNames.add(work.site);
        }
      });
      console.log('🏗️ 고유 현장:', uniqueSites);
      // 주소를 좌표로 변환
      const geocoder = new kakao.maps.services.Geocoder();
      const promises = [];
      const positions = [{
        coords: currentPos,
        siteName: '현재 위치',
        index: 0
      }];
      uniqueSites.forEach((siteName, index) => {
        const site = Object.values(sites).find(s => s.name === siteName);
        if (!site || !site.address) {
          console.warn(`⚠️ 현장 "${siteName}"의 주소 정보가 없습니다.`);
          return;
        }
        console.log(`📍 주소 검색: ${siteName} - ${site.address}`);
        const promise = new Promise((resolve) => {
          geocoder.addressSearch(site.address, function(result, status) {
            if (status === kakao.maps.services.Status.OK) {
              const coords = new kakao.maps.LatLng(result[0].y, result[0].x);
              positions.push({
                coords,
                siteName,
                index: index + 1
              });
              console.log(`✅ 좌표 변환 성공: ${siteName}`);
              resolve();
            } else {
              console.warn(`❌ 주소 검색 실패: ${site.address} (상태: ${status})`);
              resolve(); // 실패해도 resolve로 진행
            }
          });
        });
        promises.push(promise);
      });
      // 모든 주소 검색이 완료된 후 마커와 경로 표시
      Promise.all(promises).then(() => {
        console.log('📊 변환된 위치:', positions.length, '개');
        positions.sort((a, b) => a.index - b.index);
        if (positions.length < 2) {
          document.getElementById('loadingOverlay').classList.remove('active');
          document.getElementById('routeBtn').disabled = false;
          alert('경로를 표시할 현장의 주소를 찾을 수 없습니다.\n현장 관리에서 주소를 확인해주세요.');
          console.error('❌ 유효한 위치가 2개 미만');
          return;
        }
        console.log('🎨 마커 그리기 시작');
        // 현재 위치 마커 (시작점) - 레이블 포함
        const startMarkerContent = `
          <div style="position: relative;">
            <div style="
              background: #ff5722;
              color: white;
              border: 3px solid white;
              border-radius: 50%;
              width: 40px;
              height: 40px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: bold;
              font-size: 18px;
              box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            ">📍</div>
            <div style="
              position: absolute;
              top: -35px;
              left: 50%;
              transform: translateX(-50%);
              background: white;
              padding: 8px 12px;
              border-radius: 4px;
              box-shadow: 0 2px 6px rgba(0,0,0,0.3);
              white-space: nowrap;
              font-size: 13px;
              font-weight: 600;
              color: #ff5722;
            ">🚩 출발</div>
          </div>
        `;
        currentLocationMarker = new kakao.maps.CustomOverlay({
          position: positions[0].coords,
          content: startMarkerContent,
          yAnchor: 1
        });
        currentLocationMarker.setMap(map);
        // 현장 마커들 (1, 2, 3...) - 레이블 포함
        for (let i = 1; i < positions.length; i++) {
          const pos = positions[i];
          const markerContent = `
            <div style="position: relative;">
              <div style="
                background: #0d7377;
                color: white;
                border: 3px solid white;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 14px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
              ">${i}</div>
              <div style="
                position: absolute;
                top: -35px;
                left: 50%;
                transform: translateX(-50%);
                background: white;
                padding: 8px 12px;
                border-radius: 4px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                white-space: nowrap;
                font-size: 13px;
                font-weight: 600;
              ">${i}. ${pos.siteName}</div>
            </div>
          `;
          const marker = new kakao.maps.CustomOverlay({
            position: pos.coords,
            content: markerContent,
            yAnchor: 1
          });
          marker.setMap(map);
          routeMarkers.push(marker);
        }
        console.log('✏️ 경로선 그리기');
        // 경로선 그리기
        const linePath = positions.map(pos => pos.coords);
        routeLine = new kakao.maps.Polyline({
          path: linePath,
          strokeWeight: 5,
          strokeColor: '#0d7377',
          strokeOpacity: 0.9,
          strokeStyle: 'solid'
        });
        routeLine.setMap(map);
        // 화살표 표시 (경로 방향)
        for (let i = 0; i < linePath.length - 1; i++) {
          const midLat = (linePath[i].getLat() + linePath[i + 1].getLat()) / 2;
          const midLng = (linePath[i].getLng() + linePath[i + 1].getLng()) / 2;
          const midPoint = new kakao.maps.LatLng(midLat, midLng);
          const arrowContent = `
            <div style="
              color: #0d7377;
              font-size: 20px;
              text-shadow: 0 0 3px white;
            ">➜</div>
          `;
          const arrow = new kakao.maps.CustomOverlay({
            position: midPoint,
            content: arrowContent,
            yAnchor: 0.5
          });
          arrow.setMap(map);
          routeMarkers.push(arrow);
        }
        
        // 모든 마커가 보이도록 지도 범위 조정
        const bounds = new kakao.maps.LatLngBounds();
        positions.forEach(pos => bounds.extend(pos.coords));
        map.setBounds(bounds);
        document.getElementById('loadingOverlay').classList.remove('active');
        document.getElementById('routeBtn').disabled = false;
        isRouteDisplayed = true; // 🆕 경로 표시 완료 플래그
        console.log(`✅ ${positions.length - 1}개 현장 경로 표시 완료`);
      }).catch(error => {
        console.error('❌ 경로 표시 중 에러:', error);
        document.getElementById('loadingOverlay').classList.remove('active');
        document.getElementById('routeBtn').disabled = false;
        isRouteDisplayed = false; // 🆕 에러 발생 시 플래그 false
        alert('경로를 표시하는 중 오류가 발생했습니다.');
      });
    }
    // 현재 위치만 표시 (기존 기능)
    window.showCurrentLocation = function() {
      if (!map) {
        alert('지도가 초기화되지 않았습니다.');
        return;
      }
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          const locPosition = new kakao.maps.LatLng(lat, lng);
          if (currentMarker) {
            currentMarker.setMap(null);
          }
          currentMarker = new kakao.maps.Marker({
            position: locPosition,
            map: map
          });
          map.setCenter(locPosition);
          map.setLevel(3);
          const infowindow = new kakao.maps.InfoWindow({
            content: '<div style="padding:5px;font-size:12px;">현재 위치</div>'
          });
          infowindow.open(map, currentMarker);
          currentPosition = locPosition;
        }, function(error) {
          alert('위치 정보를 가져올 수 없습니다.');
          console.error(error);
        });
      } else {
        alert('이 브라우저는 위치 서비스를 지원하지 않습니다.');
      }
    };
    // 사용자 목록 로드
    function loadAssignees() {
      const assigneesRef = window.dbRef(window.db, 'assignees');
      window.dbOnValue(assigneesRef, (snapshot) => {
        assignees = [];
        const data = snapshot.val();
        if (data) {
          Object.keys(data).forEach(key => {
            assignees.push({
              id: key,
              name: data[key].name
            });
          });
        }
        renderUserGrid();
      });
    }
    // 사용자 그리드 렌더링
    function renderUserGrid() {
      const grid = document.getElementById('userGrid');
      grid.innerHTML = '';
      assignees.forEach(user => {
        const card = document.createElement('div');
        card.className = 'user-card';
        card.onclick = () => login(user.name);
        const avatar = document.createElement('div');
        avatar.className = 'user-card-avatar';
        avatar.textContent = user.name.charAt(0);
        const name = document.createElement('div');
        name.className = 'user-card-name';
        name.textContent = user.name;
        card.appendChild(avatar);
        card.appendChild(name);
        grid.appendChild(card);
      });
    }
    // 새 사용자 추가
    window.addNewUser = function() {
      const input = document.getElementById('newUserInput');
      const name = input.value.trim();
      if (!name) {
        alert('사용자 이름을 입력하세요.');
        return;
      }
      if (assignees.some(a => a.name === name)) {
        alert('이미 존재하는 사용자입니다.');
        return;
      }
      const assigneesRef = window.dbRef(window.db, 'assignees');
      const newAssigneeRef = window.dbPush(assigneesRef);
      window.dbSet(newAssigneeRef, {
        name: name
      });
      input.value = '';
    };
    // 로그인
    window.login = function(userName) {
      currentUser = userName;
      document.getElementById('loginContainer').style.display = 'none';
      document.getElementById('appContainer').classList.add('active');
      document.getElementById('userAvatar').textContent = userName.charAt(0);
      document.getElementById('headerUserName').textContent = userName;
      updateDateDisplay();
      loadWorks();
      loadSites();
      setTimeout(() => {
        console.log('🗺️ 지도 초기화 시작...');
        initMap();
        setTimeout(() => {
          if (map) {
            showCurrentLocation();
          }
        }, 800);
      }, 500);
    };
    // 로그아웃
    window.logout = function() {
      currentUser = null;
      document.getElementById('loginContainer').style.display = 'flex';
      document.getElementById('appContainer').classList.remove('active');
    };
    // 오늘 날짜로 이동
    window.goToToday = function() {
      currentDate = new Date();
      updateDateDisplay();
      renderWorks();
    };
    window.changeDate = function(days) {
      currentDate.setDate(currentDate.getDate() + days);
      updateDateDisplay();
      renderWorks();
    };

    function updateDateDisplay() {
      const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        weekday: 'short'
      };
      document.getElementById('dateDisplay').textContent = currentDate.toLocaleDateString('ko-KR', options);
    }
    window.addWork = function() {
      const site = document.getElementById('siteInput').value.trim();
      const work = document.getElementById('workInput').value.trim();
      if (!site || !work) {
        alert('현장명과 작업 내용을 입력하세요.');
        return;
      }
      const worksRef = window.dbRef(window.db, 'works');
      const todayStr = currentDate.toISOString().split('T')[0];
      const newWorkRef = window.dbPush(worksRef);
      const parentWorkId = newWorkRef.key;
      window.dbSet(newWorkRef, {
        date: todayStr,
        site: site,
        work: work,
        displayWork: work,
        assignee: currentUser,
        completed: false,
        createdAt: new Date().toISOString(),
        deadline: work === '시험' ? null : todayStr,
        order: Date.now()
      });
      if (work === '시험') {
        const testDateStr = todayStr;
        const cappingDate = addBusinessDays(testDateStr, 1);
        const cappingRef = window.dbPush(worksRef);
        window.dbSet(cappingRef, {
          date: cappingDate,
          site: site,
          work: '캡핑',
          displayWork: '캡핑',
          assignee: currentUser,
          completed: false,
          createdAt: new Date().toISOString(),
          parentWorkId: parentWorkId,
          testDate: testDateStr
        });
        const demoldingDate = addBusinessDays(testDateStr, 2);
        const demoldingRef = window.dbPush(worksRef);
        window.dbSet(demoldingRef, {
          date: demoldingDate,
          site: site,
          work: '탈형',
          displayWork: '탈형',
          assignee: currentUser,
          completed: false,
          createdAt: new Date().toISOString(),
          parentWorkId: parentWorkId,
          testDate: testDateStr
        });
        const day7Date = addCalendarDays(testDateStr, 7);
        const day7Ref = window.dbPush(worksRef);
        window.dbSet(day7Ref, {
          date: day7Date,
          site: site,
          work: '7일 강도 시험',
          displayWork: '7일 강도 시험',
          assignee: currentUser,
          completed: false,
          createdAt: new Date().toISOString(),
          parentWorkId: parentWorkId,
          testDate: testDateStr
        });
        const day28Date = addCalendarDays(testDateStr, 28);
        const day28Ref = window.dbPush(worksRef);
        window.dbSet(day28Ref, {
          date: day28Date,
          site: site,
          work: '28일 강도 시험',
          displayWork: '28일 강도 시험',
          assignee: currentUser,
          completed: false,
          createdAt: new Date().toISOString(),
          parentWorkId: parentWorkId,
          testDate: testDateStr
        });
      }
      document.getElementById('siteInput').value = '';
      document.getElementById('workInput').value = '';
    };
    // 작업 로드
    function loadWorks() {
      const worksRef = window.dbRef(window.db, 'works');
      window.dbOnValue(worksRef, (snapshot) => {
        works = snapshot.val() || {};
        renderWorks();
      });
    }
    // 현장 로드
    function loadSites() {
      const sitesRef = window.dbRef(window.db, 'sites');
      window.dbOnValue(sitesRef, (snapshot) => {
        sites = snapshot.val() || {};
        renderSiteList();
      });
    }

    function renderWorks() {
      // ✅ 드래그 중에는 렌더링하지 않음!
      if (isDraggingNow) {
        console.log('⚠️ 드래그 중 - 렌더링 건너뜀');
        return;
      }
      const searchDate = currentDate.toISOString().split('T')[0];
      const myWorks = [];
      const teamWorks = [];
      const completedWorks = [];
      Object.keys(works).forEach(workId => {
        const work = works[workId];
        let shouldShow = false;
        if (work.completed) {
          const deadline = work.deadline || work.date;
          const isOverdue = work.completedDate && deadline < work.completedDate;
          completedWorks.push({
            ...work,
            id: workId,
            displayWork: work.displayWork || work.work,
            isOverdue: isOverdue
          });
          return;
        }
        if (work.work === '시험' || work.parentWorkId) {
          shouldShow = work.date === searchDate;
        } else {
          shouldShow = work.date <= searchDate;
        }
        if (shouldShow) {
          const deadline = work.deadline || work.date;
          const isOverdue = deadline < searchDate;
          const visibleWork = {
            ...work,
            id: workId,
            displayWork: work.displayWork || work.work,
            isOverdue: isOverdue
          };
          if (work.assignee === currentUser) {
            myWorks.push(visibleWork);
          } else {
            teamWorks.push(visibleWork);
          }
        }
      });
      completedWorks.sort((a, b) => {
        const dateA = a.completedDate || a.date;
        const dateB = b.completedDate || b.date;
        return dateB.localeCompare(dateA);
      });
      const container = document.getElementById('taskContainer');
      container.innerHTML = '';
      const myActiveWorks = myWorks.filter(w => !w.completed);
      // 🆕 순서대로 정렬 - 안정적인 정렬을 위해 두 번째 기준(id) 추가
      myActiveWorks.sort((a, b) => {
        const orderA = typeof a.order === 'number' ? a.order : 999;
        const orderB = typeof b.order === 'number' ? b.order : 999;
        if (orderA === orderB) {
          // order가 같으면 id로 2차 정렬 (안정성 보장)
          return a.id.localeCompare(b.id);
        }
        return orderA - orderB;
      });
      if (myActiveWorks.length > 0) {
        const header = document.createElement('div');
        header.className = 'section-header my-work' + (sectionStates.myActive ? '' : ' collapsed');
        header.innerHTML = '<span class="section-toggle">▼</span> 📌 내 작업 진행 중 <span style="color: #0d7377; font-weight: 700;">(' + myActiveWorks.length + ')</span>';
        header.onclick = () => toggleSection('myActive');
        container.appendChild(header);
        const grid = document.createElement('div');
        grid.className = 'task-grid' + (sectionStates.myActive ? '' : ' collapsed');
        grid.id = 'myTaskGrid';
        // 🆕 순서 번호를 포함하여 카드 생성
        myActiveWorks.forEach((work, index) => {
          work.orderNumber = index + 1; // 순서 번호 추가
          grid.appendChild(createWorkCard(work, false));
        });
        container.appendChild(grid);
        // ✅ 그리드에 드래그 이벤트 등록
        grid.addEventListener('dragover', handleDragOver);
        grid.addEventListener('drop', handleDrop);
      }
      const teamActiveWorks = teamWorks.filter(w => !w.completed);
      if (teamActiveWorks.length > 0) {
        if (myActiveWorks.length > 0) {
          const divider = document.createElement('div');
          divider.className = 'section-divider';
          container.appendChild(divider);
        }
        const header = document.createElement('div');
        header.className = 'section-header' + (sectionStates.teamActive ? '' : ' collapsed');
        header.innerHTML = '<span class="section-toggle">▼</span> 👥 팀 작업 진행 중 <span style="color: #666; font-weight: 700;">(' + teamActiveWorks.length + ')</span>';
        header.onclick = () => toggleSection('teamActive');
        container.appendChild(header);
        const grid = document.createElement('div');
        grid.className = 'task-grid' + (sectionStates.teamActive ? '' : ' collapsed');
        grid.id = 'teamTaskGrid';
        teamActiveWorks.forEach(work => {
          grid.appendChild(createWorkCard(work, false));
        });
        container.appendChild(grid);
      }
      if (completedWorks.length > 0) {
        if (myWorks.length > 0 || teamWorks.length > 0) {
          const divider = document.createElement('div');
          divider.className = 'section-divider';
          container.appendChild(divider);
        }
        const header = document.createElement('div');
        header.className = 'section-header' + (sectionStates.completed ? '' : ' collapsed');
        header.innerHTML = `<span class="section-toggle">▼</span> ✅ 완료됨 <span style="color: #4caf50; font-weight: 700;">(${completedWorks.length})</span>`;
        header.onclick = () => toggleSection('completed');
        container.appendChild(header);
        const grid = document.createElement('div');
        grid.className = 'task-grid' + (sectionStates.completed ? '' : ' collapsed');
        grid.id = 'completedTaskGrid';
        grid.style.maxHeight = '400px';
        grid.style.overflowY = 'auto';
        completedWorks.forEach(work => {
          grid.appendChild(createWorkCard(work, true));
        });
        container.appendChild(grid);
      }
      if (myWorks.length === 0 && teamWorks.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = `
          <div class="empty-icon">📋</div>
          <div>이 날짜에 예정된 작업이 없습니다</div>
        `;
        container.appendChild(emptyState);
      }
    }
    // 섹션 접기/펼치기 토글
    function toggleSection(sectionKey) {
      sectionStates[sectionKey] = !sectionStates[sectionKey];
      renderWorks();
    }
    // 작업 카드 생성
    function createWorkCard(work, isCompleted) {
      const card = document.createElement('div');
      card.className = 'task-card' + (isCompleted ? ' completed' : '');
      if (!isCompleted && work.isOverdue) {
        card.classList.add('overdue');
      }
      // 내 작업은 항상 draggable = true (하지만 canDrag 플래그로 제어)
      if (work.assignee === currentUser && !isCompleted) {
        card.draggable = true;
      } else {
        card.draggable = false;
      }
      card.dataset.workId = work.id;
      if (work.assignee === currentUser) {
        card.classList.add('my-task');
      }
      // 드래그 허용 플래그
      let canDrag = false;
      if (!isCompleted) {
        card.addEventListener('dragstart', (e) => {
          // 드래그 핸들을 통해서만 허용
          if (!canDrag) {
            e.preventDefault();
            return;
          }
          handleDragStart.call(card, e);
        });
        card.addEventListener('dragend', handleDragEnd);
        // dragover, drop, dragleave는 그리드에 등록!
      }
      if (!isCompleted) {
        const dragHandle = document.createElement('div');
        dragHandle.className = 'drag-handle';
        dragHandle.textContent = '⋮⋮';
        // PC용 드래그
        dragHandle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          canDrag = true; // 드래그 허용
        });
        dragHandle.addEventListener('mouseup', (e) => {
          setTimeout(() => {
            canDrag = false; // 드래그 금지
          }, 100);
        });
        // 🆕 모바일용 터치 드래그 (개선된 버전)
        let touchStartY = 0;
        let touchCurrentY = 0;
        let isDragging = false;
        let scrollContainer = null;
        let touchStartOrder = []; // 🆕 터치 시작 시 원래 순서 저장
        dragHandle.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          touchStartY = e.touches[0].clientY;
          isDragging = false; // 아직 드래그 시작 안함
          // 스크롤 컨테이너 찾기
          scrollContainer = card.closest('.task-container');
          
          // 🆕 PC와 동일: 드래그 시작 시 원래 순서 저장
          const grid = card.closest('.task-grid');
          if (grid) {
            touchStartOrder = Array.from(grid.querySelectorAll('.task-card')).map(c => c.dataset.workId);
          }
          
          console.log('🟢 터치 시작:', work.site);
          console.log('🟢 원래 순서:', touchStartOrder);
        });
        dragHandle.addEventListener('touchmove', (e) => {
          touchCurrentY = e.touches[0].clientY;
          const deltaY = Math.abs(touchCurrentY - touchStartY);
          
          // 🆕 5px 이상 움직이면 드래그로 인식 (더 민감하게)
          if (deltaY > 5) {
            if (!isDragging) {
              isDragging = true;
              card.classList.add('dragging');
              console.log('🔵 드래그 시작');
              
              // 🆕 드래그 시작 시 body 스크롤 완전히 막기
              document.body.style.overflow = 'hidden';
              document.body.style.position = 'fixed';
              document.body.style.width = '100%';
            }
            
            // 🆕 드래그 중 항상 스크롤 방지
            e.preventDefault();
            e.stopPropagation();
            
            // 현재 터치 위치의 엘리먼트 찾기
            const touch = e.touches[0];
            // 중요: 드래그 중인 카드를 임시로 숨기고 아래 엘리먼트 찾기
            const originalVisibility = card.style.visibility;
            card.style.visibility = 'hidden';
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            card.style.visibility = originalVisibility;
            const targetCard = elementBelow?.closest('.task-card');
            // 모든 카드의 drag-over 제거
            document.querySelectorAll('.task-card').forEach(c => c.classList.remove('drag-over'));
            // 타겟 카드에 drag-over 추가
            // ✅ 타겟 카드에 실제로 DOM 순서 변경 (PC와 동일!)
            if (targetCard && targetCard !== card && !targetCard.classList.contains('completed')) {
              targetCard.classList.add('drag-over');
              console.log('🎯 타겟 위에:', works[targetCard.dataset.workId]?.site);
              
              // ✅ PC의 handleDragOver와 동일한 로직
              const container = card.closest('.task-grid');
              const targetContainer = targetCard.closest('.task-grid');
              
              if (container && targetContainer && container === targetContainer && container.id === 'myTaskGrid') {
                // 터치 위치가 타겟 카드의 위/아래 중 어디?
                const rect = targetCard.getBoundingClientRect();
                const touchY = touch.clientY;
                const middle = rect.top + rect.height / 2;
                
                if (touchY < middle) {
                  // 위쪽 절반 → 타겟 앞에 삽입
                  container.insertBefore(card, targetCard);
                } else {
                  // 아래쪽 절반 → 타겟 뒤에 삽입
                  const nextCard = targetCard.nextElementSibling;
                  if (nextCard && nextCard !== card) {
                    container.insertBefore(card, nextCard);
                  } else {
                    container.appendChild(card);
                  }
                }
              }
            }
          }
        }, {
          passive: false
        });
        dragHandle.addEventListener('touchend', (e) => {
          if (!isDragging) {
            // 드래그가 아니라 그냥 탭이었음
            console.log('❌ 드래그 없음 (탭)');
            card.classList.remove('dragging');
            document.querySelectorAll('.task-card').forEach(c => c.classList.remove('drag-over'));
            return;
          }
          const touch = e.changedTouches[0];
          // 드래그 중인 카드를 임시로 숨기고 타겟 찾기
          card.style.visibility = 'hidden';
          const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
          card.style.visibility = 'visible';
          const targetCard = elementBelow?.closest('.task-card');
          console.log('🔴 터치 종료');
          console.log('   드래그:', work.site);
          console.log('   타겟:', targetCard ? works[targetCard.dataset.workId]?.site : '없음');
          
          // ✅ 드래그 종료 처리 - PC와 동일한 순서 변경 체크!
          const grid = card.closest('.task-grid');
          if (grid && grid.id === 'myTaskGrid') {
            const cards = Array.from(grid.querySelectorAll('.task-card'));
            const currentOrder = cards.map(c => c.dataset.workId);
            
            // 🆕 PC와 동일: 순서가 실제로 변경되었는지 확인
            const hasChanged = !touchStartOrder.every((id, index) => id === currentOrder[index]);
            
            console.log('🔴 모바일 터치 종료');
            console.log('   원래 순서:', touchStartOrder);
            console.log('   현재 순서:', currentOrder);
            console.log('   변경됨?', hasChanged);
            
            if (!hasChanged) {
              console.log('❌ 순서 변경 없음 - 저장 안 함');
              // 정리
              // 정리
              card.classList.remove('dragging');
              document.querySelectorAll('.task-card').forEach(c => c.classList.remove('drag-over'));
              isDragging = false;
              
              // 🆕 스크롤 복원
              document.body.style.overflow = '';
              document.body.style.position = '';
              document.body.style.width = '';
              return;
            }
            
            // 변경되었을 때만 저장
            const updates = {};
            cards.forEach((c, index) => {
              const workId = c.dataset.workId;
              if (workId && works[workId]) {
                updates[`works/${workId}/order`] = index;
                works[workId].order = index;
              }
            });
          
            window.dbUpdate(window.dbRef(window.db), updates).then(() => {
              console.log('✅ 모바일 드래그 - 순서 저장 완료');
              
              // 🆕 화면 갱신으로 순서 번호 재정렬
              renderWorks();
              
              // 🆕 경로가 표시 중이면 자동으로 업데이트
              if (isRouteDisplayed && currentPosition) {
                console.log('🔄 모바일: 경로 자동 업데이트');
                const searchDate = currentDate.toISOString().split('T')[0];
                const myActiveWorks = [];
                Object.keys(works).forEach(workId => {
                  const work = works[workId];
                  if (work.completed) return;
                  if (work.assignee !== currentUser) return;
                  let shouldShow = false;
                  if (work.work === '시험' || work.parentWorkId) {
                    shouldShow = work.date === searchDate;
                  } else {
                    shouldShow = work.date <= searchDate;
                  }
                  if (shouldShow) {
                    myActiveWorks.push(work);
                  }
                });
                // 정렬 (새 순서로!)
                myActiveWorks.sort((a, b) => {
                  const orderA = typeof a.order === 'number' ? a.order : 999;
                  const orderB = typeof b.order === 'number' ? b.order : 999;
                  if (orderA === orderB) {
                    return a.id.localeCompare(b.id);
                  }
                  return orderA - orderB;
                });
                if (myActiveWorks.length > 0) {
                  drawRouteFromCurrentLocation(currentPosition, myActiveWorks);
                }
              }
            });
          
            // 햅틱 피드백
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
          }
          
          // 정리
          card.classList.remove('dragging');
          document.querySelectorAll('.task-card').forEach(c => c.classList.remove('drag-over'));
          isDragging = false;
        }, {
          passive: false
        });
        card.appendChild(dragHandle);
        // 순서 번호 추가
        if (work.orderNumber) {
          const orderNum = document.createElement('div');
          orderNum.className = 'order-number';
          orderNum.textContent = work.orderNumber;
          card.appendChild(orderNum);
        }
      }
      const checkbox = document.createElement('div');
      checkbox.className = 'task-checkbox';
      checkbox.onclick = (e) => {
        e.stopPropagation();
        toggleComplete(work.id);
      };
      card.appendChild(checkbox);
      const cardBody = document.createElement('div');
      cardBody.className = 'task-card-body';
      const title = document.createElement('div');
      title.className = 'task-title';
      title.textContent = `${work.site} - ${work.displayWork}`;
      if (!isCompleted && work.isOverdue) {
        const warningBadge = document.createElement('span');
        warningBadge.className = 'overdue-warning';
        warningBadge.textContent = '⚠️ 기한초과';
        title.appendChild(document.createTextNode(' '));
        title.appendChild(warningBadge);
      }
      if (work.testDate) {
        title.style.cursor = 'pointer';
        title.onclick = (e) => {
          e.stopPropagation();
          showTimeline(work);
        };
      }
      cardBody.appendChild(title);
      if (work.work !== '시험' && !work.parentWorkId) {
        const deadlineContainer = document.createElement('div');
        deadlineContainer.className = 'deadline-label-container';
        deadlineContainer.onclick = (e) => {
          e.stopPropagation();
          if (!isCompleted) {
            openDeadlineModal(work.id, work.deadline || work.date);
          }
        };
        const deadlineLabel = document.createElement('span');
        deadlineLabel.className = 'deadline-label-text';
        deadlineLabel.textContent = '완료 기한:';
        const deadlineDate = document.createElement('span');
        deadlineDate.className = 'deadline-date-tag';
        if (!isCompleted && work.isOverdue) {
          deadlineDate.classList.add('overdue');
        }
        deadlineDate.textContent = work.deadline || work.date;
        deadlineContainer.appendChild(deadlineLabel);
        deadlineContainer.appendChild(deadlineDate);
        cardBody.appendChild(deadlineContainer);
      }
      if (work.testDate) {
        const dateLabel = document.createElement('span');
        dateLabel.className = 'date-label';
        dateLabel.textContent = '작업등록일자:';
        cardBody.appendChild(dateLabel);
        const testDateTag = document.createElement('span');
        testDateTag.className = 'test-date-label';
        testDateTag.textContent = work.testDate;
        cardBody.appendChild(testDateTag);
      }
      if (isCompleted && work.completedDate) {
        const completedInfo = document.createElement('div');
        completedInfo.style.cssText = 'margin-top: 8px; font-size: 12px; color: #4caf50;';
        const completedLabel = document.createElement('span');
        completedLabel.textContent = '✓ 완료: ';
        completedLabel.style.fontWeight = '600';
        const completedDate = document.createElement('span');
        completedDate.textContent = work.completedDate;
        const completedBy = document.createElement('span');
        completedBy.textContent = ` (담당: ${work.assignee || '미정'})`;
        completedBy.style.color = '#666';
        completedInfo.appendChild(completedLabel);
        completedInfo.appendChild(completedDate);
        completedInfo.appendChild(completedBy);
        cardBody.appendChild(completedInfo);
      }
      card.appendChild(cardBody);
      const personContainer = document.createElement('div');
      personContainer.className = 'person-select-container';
      const assigneeWrapper = document.createElement('div');
      assigneeWrapper.className = 'select-wrapper';
      const assigneeLabel = document.createElement('label');
      assigneeLabel.className = 'select-label';
      assigneeLabel.textContent = '담당자';
      const assigneeSelect = document.createElement('select');
      assigneeSelect.className = 'assignee-select';
      assigneeSelect.onclick = (e) => e.stopPropagation();
      if (isCompleted) assigneeSelect.disabled = true;
      const assigneeDefaultOption = document.createElement('option');
      assigneeDefaultOption.value = '';
      assigneeDefaultOption.textContent = '선택';
      assigneeSelect.appendChild(assigneeDefaultOption);
      assignees.forEach(assignee => {
        const option = document.createElement('option');
        option.value = assignee.name;
        option.textContent = assignee.name;
        if (work.assignee === assignee.name) {
          option.selected = true;
        }
        assigneeSelect.appendChild(option);
      });
      if (!isCompleted) {
        assigneeSelect.onchange = () => saveAssignee(work.id, assigneeSelect.value);
      }
      assigneeWrapper.appendChild(assigneeLabel);
      assigneeWrapper.appendChild(assigneeSelect);
      personContainer.appendChild(assigneeWrapper);
      card.appendChild(personContainer);
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'action-btn';
      deleteBtn.textContent = '🗑️';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteWork(work.id);
      };
      card.appendChild(deleteBtn);
      return card;
    }
    // 드래그 관련 함수들
    function handleDragStart(e) {
      draggedElement = this;
      draggedWorkId = this.dataset.workId;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
      // ✅ 드래그 시작 시 원래 순서 저장
      isDraggingNow = true;
      const grid = this.closest('.task-grid');
      if (grid) {
        originalOrder = Array.from(grid.querySelectorAll('.task-card')).map(card => card.dataset.workId);
      }
      console.log('🟢 드래그 시작 - 원래 순서:', originalOrder);
    }

    function handleDragEnd(e) {
      this.classList.remove('dragging');
      const grid = this.closest('.task-grid');
      if (grid && grid.id === 'myTaskGrid') {
        const cards = Array.from(grid.querySelectorAll('.task-card'));
        const currentOrder = cards.map(card => card.dataset.workId);
        // ✅ 순서가 실제로 변경되었는지 확인
        const hasChanged = !originalOrder.every((id, index) => id === currentOrder[index]);
        console.log('🔴 드래그 종료');
        console.log('   원래 순서:', originalOrder);
        console.log('   현재 순서:', currentOrder);
        console.log('   변경됨?', hasChanged);
        if (!hasChanged) {
          console.log('❌ 순서 변경 없음 - 저장 안 함');
          isDraggingNow = false;
          return;
        }
        // ✅ 변경되었을 때만 저장 - 먼저 로컬에서 업데이트
        const updates = {};
        cards.forEach((card, index) => {
          const workId = card.dataset.workId;
          if (workId && works[workId]) {
            updates[`works/${workId}/order`] = index;
            works[workId].order = index; // 즉시 로컬 업데이트
          }
        });
        // Firebase 업데이트 후 드래그 상태 해제
        // Firebase 업데이트 후 드래그 상태 해제
        window.dbUpdate(window.dbRef(window.db), updates).then(() => {
          console.log('✅ 순서 저장 완료!');
          isDraggingNow = false;
          
          // 🆕 화면 갱신으로 순서 번호 재정렬
          renderWorks();
          
          // 🆕 경로가 표시 중이면 자동으로 업데이트
          if (isRouteDisplayed && currentPosition) {
            console.log('🔄 경로 자동 업데이트');
            const searchDate = currentDate.toISOString().split('T')[0];
            const myActiveWorks = [];
            Object.keys(works).forEach(workId => {
              const work = works[workId];
              if (work.completed) return;
              if (work.assignee !== currentUser) return;
              let shouldShow = false;
              if (work.work === '시험' || work.parentWorkId) {
                shouldShow = work.date === searchDate;
              } else {
                shouldShow = work.date <= searchDate;
              }
              if (shouldShow) {
                myActiveWorks.push(work);
              }
            });
            // 정렬 (새 순서로!)
            myActiveWorks.sort((a, b) => {
              const orderA = typeof a.order === 'number' ? a.order : 999;
              const orderB = typeof b.order === 'number' ? b.order : 999;
              if (orderA === orderB) {
                return a.id.localeCompare(b.id);
              }
              return orderA - orderB;
            });
            if (myActiveWorks.length > 0) {
              drawRouteFromCurrentLocation(currentPosition, myActiveWorks);
            }
          }
        }).catch(() => {
          isDraggingNow = false;
        });
      } else {
        isDraggingNow = false;
      }
    }

    function handleDragOver(e) {
      e.preventDefault();
      
      const draggedCard = document.querySelector('.dragging');
      if (!draggedCard) return;
      
      // ✅ 마우스가 올라간 카드 찾기
      const targetCard = e.target.closest('.task-card');
      if (!targetCard || targetCard === draggedCard) return;
      if (targetCard.classList.contains('completed')) return;
      
      // ✅ 같은 그리드 내에서만
      const container = draggedCard.closest('.task-grid');
      const targetContainer = targetCard.closest('.task-grid');
      if (!container || !targetContainer || container !== targetContainer) return;
      if (container.id !== 'myTaskGrid') return;
      
      // ✅ 마우스가 타겟 카드의 위쪽/아래쪽 중 어디에?
      const rect = targetCard.getBoundingClientRect();
      const mouseY = e.clientY;
      const middle = rect.top + rect.height / 2;
      
      // ✅ 간단하고 정확한 삽입!
      if (mouseY < middle) {
        // 위쪽 절반 → 타겟 앞에 삽입
        container.insertBefore(draggedCard, targetCard);
      } else {
        // 아래쪽 절반 → 타겟 뒤에 삽입
        const nextCard = targetCard.nextElementSibling;
        if (nextCard && nextCard !== draggedCard) {
          container.insertBefore(draggedCard, nextCard);
        } else {
          container.appendChild(draggedCard);
        }
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      // handleDragEnd에서 저장할 것이므로 여기서는 아무것도 안 함
      return false;
    }
    // 시험 작업 타임라인 표시
    function showTimeline(work) {
      const modal = document.getElementById('timelineModal');
      const title = document.getElementById('timelineTitle');
      const content = document.getElementById('timelineContent');
      title.textContent = `${work.site} - 시험 타임라인`;
      content.innerHTML = '';
      const parentId = work.parentWorkId || work.id;
      const parentWork = works[parentId];
      if (!parentWork) return;
      const timeline = [{
        work: '시험',
        date: parentWork.date,
        id: parentId,
        completed: parentWork.completed
      }];
      Object.keys(works).forEach(id => {
        if (works[id].parentWorkId === parentId) {
          timeline.push({
            work: works[id].work,
            date: works[id].date,
            id: id,
            completed: works[id].completed
          });
        }
      });
      timeline.sort((a, b) => a.date.localeCompare(b.date));
      timeline.forEach(item => {
        const timelineItem = document.createElement('div');
        timelineItem.className = 'timeline-item';
        if (item.id === work.id) {
          timelineItem.classList.add('active');
        }
        const workDiv = document.createElement('div');
        workDiv.className = 'timeline-work';
        workDiv.textContent = `${item.completed ? '✓ ' : ''}${item.work}`;
        if (item.completed) {
          workDiv.style.textDecoration = 'line-through';
          workDiv.style.color = '#999';
        }
        const dateDiv = document.createElement('div');
        dateDiv.className = 'timeline-date';
        dateDiv.textContent = item.date;
        timelineItem.appendChild(workDiv);
        timelineItem.appendChild(dateDiv);
        content.appendChild(timelineItem);
      });
      modal.classList.add('active');
    }
    window.closeTimelineModal = function() {
      document.getElementById('timelineModal').classList.remove('active');
    };
    // 작업 완료 토글
    function toggleComplete(workId) {
      const work = works[workId];
      if (!work) return;
      const workRef = window.dbRef(window.db, `works/${workId}`);
      const isCompleting = !work.completed;
      const updateData = {
        completed: isCompleting
      };
      if (isCompleting) {
        updateData.completedDate = new Date().toISOString().split('T')[0];
      } else {
        updateData.completedDate = null;
      }
      window.dbUpdate(workRef, updateData);
    }
    // 담당자 저장
    function saveAssignee(workId, assignee) {
      const workRef = window.dbRef(window.db, `works/${workId}`);
      window.dbUpdate(workRef, {
        assignee: assignee
      });
    }
    // 작업 삭제
    function deleteWork(workId) {
      const work = works[workId];
      if (!work) return;
      if (work.work === '시험') {
        if (!confirm('이 시험 작업과 관련된 모든 작업(캡핑, 탈형, 7일강도, 28일강도)을 삭제하시겠습니까?')) return;
        Object.keys(works).forEach(id => {
          if (works[id].parentWorkId === workId) {
            const childWorkRef = window.dbRef(window.db, `works/${id}`);
            window.dbRemove(childWorkRef);
          }
        });
      } else {
        if (!confirm('이 작업을 삭제하시겠습니까?')) return;
      }
      const workRef = window.dbRef(window.db, `works/${workId}`);
      window.dbRemove(workRef);
    }
    // 현장 관리
    window.toggleSiteModal = function() {
      const modal = document.getElementById('siteModal');
      modal.classList.toggle('active');
      if (modal.classList.contains('active')) {
        renderSiteList();
      }
    };
    window.toggleSiteSelectModal = function() {
      const modal = document.getElementById('siteSelectModal');
      modal.classList.toggle('active');
      if (modal.classList.contains('active')) {
        renderSiteSelectList();
      }
    };

    function renderSiteList() {
      const list = document.getElementById('siteList');
      list.innerHTML = '';
      Object.keys(sites).forEach(id => {
        const site = sites[id];
        const li = document.createElement('li');
        li.className = 'site-item';
        const infoDiv = document.createElement('div');
        infoDiv.className = 'site-item-info';
        const name = document.createElement('div');
        name.className = 'site-item-name';
        name.textContent = site.name;
        const address = document.createElement('div');
        address.className = 'site-item-address';
        address.textContent = site.address || '주소 없음';
        infoDiv.appendChild(name);
        infoDiv.appendChild(address);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'site-item-delete';
        deleteBtn.textContent = '삭제';
        deleteBtn.onclick = () => deleteSite(id);
        li.appendChild(infoDiv);
        li.appendChild(deleteBtn);
        list.appendChild(li);
      });
    }

    function renderSiteSelectList() {
      const list = document.getElementById('siteSelectList');
      list.innerHTML = '';
      Object.keys(sites).forEach(id => {
        const site = sites[id];
        const li = document.createElement('li');
        li.className = 'site-item';
        li.onclick = () => selectSite(site.name);
        const name = document.createElement('span');
        name.className = 'site-item-name';
        name.textContent = site.name;
        li.appendChild(name);
        list.appendChild(li);
      });
    }

    function selectSite(siteName) {
      document.getElementById('siteInput').value = siteName;
      toggleSiteSelectModal();
    }
    window.addSite = function() {
      const nameInput = document.getElementById('newSiteName');
      const addressInput = document.getElementById('newSiteAddress');
      const name = nameInput.value.trim();
      const address = addressInput.value.trim();
      if (!name) {
        alert('현장명을 입력하세요.');
        return;
      }
      if (!address) {
        alert('주소를 입력하세요.');
        return;
      }
      const sitesRef = window.dbRef(window.db, 'sites');
      const newSiteRef = window.dbPush(sitesRef);
      window.dbSet(newSiteRef, {
        name: name,
        address: address,
        createdAt: new Date().toISOString()
      });
      nameInput.value = '';
      addressInput.value = '';
      alert('현장이 추가되었습니다.');
    };

    function deleteSite(id) {
      if (!confirm('이 현장을 삭제하시겠습니까?')) return;
      const siteRef = window.dbRef(window.db, `sites/${id}`);
      window.dbRemove(siteRef);
    }

    function calculateBusinessDays(startDate, endDate) {
      if (startDate > endDate) return -1;
      let count = 0;
      let curDate = new Date(startDate.getTime());
      while (curDate < endDate) {
        const dayOfWeek = curDate.getDay();
        if (dayOfWeek != 0 && dayOfWeek != 6) count++;
        curDate.setDate(curDate.getDate() + 1);
      }
      return count;
    }

    function calculateAbsoluteDays(startDate, endDate) {
      const oneDay = 24 * 60 * 60 * 1000;
      const diffDays = Math.round((endDate - startDate) / oneDay);
      return diffDays;
    }

    function addBusinessDays(startDate, businessDays) {
      const date = new Date(startDate);
      let count = 0;
      while (count < businessDays) {
        date.setDate(date.getDate() + 1);
        if (date.getDay() !== 0 && date.getDay() !== 6) {
          count++;
        }
      }
      return date.toISOString().split('T')[0];
    }

    function addCalendarDays(startDate, days) {
      const date = new Date(startDate);
      date.setDate(date.getDate() + days);
      return date.toISOString().split('T')[0];
    }
    // 모달 외부 클릭 시 닫기
    document.getElementById('timelineModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('timelineModal')) {
        closeTimelineModal();
      }
    });
    document.getElementById('siteModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('siteModal')) {
        toggleSiteModal();
      }
    });
    document.getElementById('siteSelectModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('siteSelectModal')) {
        toggleSiteSelectModal();
      }
    });
    // Enter 키 이벤트
    document.getElementById('siteInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('workInput').focus();
      }
    });
    document.getElementById('workInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addWork();
    });
    document.getElementById('newUserInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addNewUser();
    });
    document.getElementById('newSiteName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addSite();
    });
    // 완료 기한 관련 변수
    let currentEditingWorkId = null;

    function openDeadlineModal(workId, currentDeadline) {
      currentEditingWorkId = workId;
      const modal = document.getElementById('deadlineModal');
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const friday = new Date(today);
      const day = today.getDay();
      const diff = (5 - day + 7) % 7;
      friday.setDate(friday.getDate() + (diff === 0 ? 7 : diff));
      document.getElementById('todayDate').textContent = today.toISOString().split('T')[0];
      document.getElementById('tomorrowDate').textContent = tomorrow.toISOString().split('T')[0];
      document.getElementById('thisWeekDate').textContent = friday.toISOString().split('T')[0];
      document.getElementById('customDeadlineInput').value = currentDeadline;
      modal.classList.add('active');
    }
    window.selectDeadline = function(option) {
      if (!currentEditingWorkId) return;
      let selectedDate;
      const today = new Date();
      switch (option) {
        case 'today':
          selectedDate = today.toISOString().split('T')[0];
          break;
        case 'tomorrow':
          const tomorrow = new Date(today);
          tomorrow.setDate(tomorrow.getDate() + 1);
          selectedDate = tomorrow.toISOString().split('T')[0];
          break;
        case 'thisWeek':
          const friday = new Date(today);
          const day = today.getDay();
          const diff = (5 - day + 7) % 7;
          friday.setDate(friday.getDate() + (diff === 0 ? 7 : diff));
          selectedDate = friday.toISOString().split('T')[0];
          break;
        case 'custom':
          selectedDate = document.getElementById('customDeadlineInput').value;
          if (!selectedDate) {
            alert('날짜를 선택하세요.');
            return;
          }
          break;
      }
      const workRef = window.dbRef(window.db, `works/${currentEditingWorkId}`);
      window.dbUpdate(workRef, {
        deadline: selectedDate
      });
      document.getElementById('deadlineModal').classList.remove('active');
      currentEditingWorkId = null;
    };
    document.getElementById('deadlineModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('deadlineModal')) {
        document.getElementById('deadlineModal').classList.remove('active');
        currentEditingWorkId = null;
      }
    });
    // 초기화
    window.onload = function() {
      waitForFirebase();
    };
  </script>
</body>

</html>
